import { Validators, FormControl, NgModel, NG_VALIDATORS } from '@angular/forms';
import { Directive, Input, forwardRef, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
import * as Éµngcc0 from '@angular/core';
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * @param {?} obj
 * @return {?}
 */
function isDate(obj) {
    return !/Invalid|NaN/.test(new Date(obj).toString());
}
/**
 * @param {?} obj
 * @return {?}
 */
function parseDate(obj) {
    try {
        if (typeof obj === 'object' && obj.year != null && obj.month != null && obj.day != null) {
            return obj.year + '-' + obj.month + '-' + obj.day;
        }
    }
    catch (/** @type {?} */ e) { }
    return obj;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const arrayLength = (value) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ obj = control.value;
        return Array.isArray(obj) && obj.length >= +value ? null : { arrayLength: +value };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const base64 = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    return /^(?:[A-Z0-9+\/]{4})*(?:[A-Z0-9+\/]{2}==|[A-Z0-9+\/]{3}=|[A-Z0-9+\/]{4})$/i.test(v) ? null : { 'base64': true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const creditCard = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    const /** @type {?} */ sanitized = v.replace(/[^0-9]+/g, '');
    // problem with chrome
    /* tslint:disable */
    if (!(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|(?:9792)\d{12})$/.test(sanitized))) {
        return { creditCard: true };
    }
    /* tslint:enable */
    let /** @type {?} */ sum = 0;
    let /** @type {?} */ digit;
    let /** @type {?} */ tmpNum;
    let /** @type {?} */ shouldDouble;
    for (let /** @type {?} */ i = sanitized.length - 1; i >= 0; i--) {
        digit = sanitized.substring(i, (i + 1));
        tmpNum = parseInt(digit, 10);
        if (shouldDouble) {
            tmpNum *= 2;
            if (tmpNum >= 10) {
                sum += ((tmpNum % 10) + 1);
            }
            else {
                sum += tmpNum;
            }
        }
        else {
            sum += tmpNum;
        }
        shouldDouble = !shouldDouble;
    }
    if (Boolean((sum % 10) === 0 ? sanitized : false)) {
        return null;
    }
    return { creditCard: true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const date = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    return isDate(v) ? null : { date: true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const dateISO = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    return /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(v) ? null : { dateISO: true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const digits = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    return /^\d+$/.test(v) ? null : { digits: true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const email = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    /* tslint:disable */
    return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v) ? null : { 'email': true };
    /* tslint:enable */
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const equal = (val) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = control.value;
        return val === v ? null : { equal: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const equalTo = (equalControl) => {
    let /** @type {?} */ subscribe = false;
    return (control) => {
        if (!subscribe) {
            subscribe = true;
            equalControl.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        const /** @type {?} */ v = control.value;
        return equalControl.value === v ? null : { equalTo: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const gt = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v > +value ? null : { gt: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const gte = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v >= +value ? null : { gte: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const json = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    try {
        const /** @type {?} */ obj = JSON.parse(v);
        if (Boolean(obj) && typeof obj === 'object') {
            return null;
        }
    }
    catch (/** @type {?} */ e) { }
    return { json: true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const lt = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v < +value ? null : { lt: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const lte = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v <= +value ? null : { lte: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const max = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v <= +value ? null : { actualValue: v, requiredValue: +value, max: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const maxDate = (maxInput) => {
    let /** @type {?} */ value;
    let /** @type {?} */ subscribe = false;
    let /** @type {?} */ maxValue = maxInput;
    const /** @type {?} */ isForm = maxInput instanceof FormControl || maxInput instanceof NgModel;
    return (control) => {
        if (!subscribe && isForm) {
            subscribe = true;
            maxInput.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        if (isForm) {
            maxValue = maxInput.value;
        }
        value = parseDate(maxValue);
        if (!isDate(value) && !(value instanceof Function)) {
            if (value == null) {
                return null;
            }
            else if (isForm) {
                return { maxDate: true, error: 'maxDate is invalid' };
            }
            else {
                throw Error('maxDate value must be or return a formatted date');
            }
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ d = new Date(parseDate(control.value)).getTime();
        if (!isDate(d)) {
            return { value: true };
        }
        if (value instanceof Function) {
            value = value();
        }
        return d <= new Date(value).getTime() ? null : { maxDate: true, error: 'greater than maxDate' };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const min = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v >= +value ? null : { actualValue: v, requiredValue: +value, min: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const minDate = (minInput) => {
    let /** @type {?} */ value;
    let /** @type {?} */ subscribe = false;
    let /** @type {?} */ minValue = minInput;
    const /** @type {?} */ isForm = minInput instanceof FormControl || minInput instanceof NgModel;
    return (control) => {
        if (!subscribe && isForm) {
            subscribe = true;
            minInput.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        if (isForm) {
            minValue = minInput.value;
        }
        value = parseDate(minValue);
        if (!isDate(value) && !(value instanceof Function)) {
            if (value == null) {
                return null;
            }
            else if (isForm) {
                return { minDate: true, error: 'minDate is invalid' };
            }
            else {
                throw Error('minDate value must be or return a formatted date');
            }
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ d = new Date(parseDate(control.value)).getTime();
        if (!isDate(d)) {
            return { value: true };
        }
        if (value instanceof Function) {
            value = value();
        }
        return d >= new Date(value).getTime() ? null : { minDate: true, error: 'lower than minDate' };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const notEqual = (val) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = control.value;
        return val !== v ? null : { notEqual: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const notEqualTo = (notEqualControl) => {
    let /** @type {?} */ subscribe = false;
    return (control) => {
        if (!subscribe) {
            subscribe = true;
            notEqualControl.valueChanges.subscribe(() => {
                control.updateValueAndValidity();
            });
        }
        const /** @type {?} */ v = control.value;
        return notEqualControl.value !== v ? null : { notEqualTo: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const number = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    return /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(v) ? null : { 'number': true };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const property = (value) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ properties = value.split(',');
        const /** @type {?} */ obj = control.value;
        let /** @type {?} */ isValid = true;
        for (const /** @type {?} */ prop of properties) {
            if (obj[prop] == null) {
                isValid = false;
                break;
            }
        }
        return isValid ? null : { hasProperty: true, property: value };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const range = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = +control.value;
        return v >= value[0] && v <= value[1] ? null : { actualValue: v, requiredValue: value, range: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const rangeLength = (value) => {
    return (control) => {
        if (!isPresent(value)) {
            return null;
        }
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = control.value;
        return v.length >= value[0] && v.length <= value[1] ? null : { rangeLength: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const uuids = {
    '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    'all': /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};
const uuid = (version) => {
    return (control) => {
        if (isPresent(Validators.required(control))) {
            return null;
        }
        const /** @type {?} */ v = control.value;
        const /** @type {?} */ pattern = uuids[version] || uuids.all;
        return (new RegExp(pattern)).test(v) ? null : { uuid: true };
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const url = (control) => {
    if (isPresent(Validators.required(control))) {
        return null;
    }
    const /** @type {?} */ v = control.value;
    /* tslint:disable */
    return /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(v) ? null : { 'url': true };
    /* tslint:enable */
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ARRAY_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => ArrayLengthValidator),
    multi: true
};
class ArrayLengthValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = arrayLength(this.arrayLength);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'arrayLength') {
                this.validator = arrayLength(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
ArrayLengthValidator.Éµfac = function ArrayLengthValidator_Factory(t) { return new (t || ArrayLengthValidator)(); };
ArrayLengthValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: ArrayLengthValidator, selectors: [["", "arrayLength", "", "formControlName", ""], ["", "arrayLength", "", "formControl", ""], ["", "arrayLength", "", "ngModel", ""]], inputs: { arrayLength: "arrayLength" }, features: [Éµngcc0.ÉµÉµProvidersFeature([ARRAY_LENGTH_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
ArrayLengthValidator.propDecorators = {
    arrayLength: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(ArrayLengthValidator, [{
        type: Directive,
        args: [{
                selector: '[arrayLength][formControlName],[arrayLength][formControl],[arrayLength][ngModel]',
                providers: [ARRAY_LENGTH_VALIDATOR]
            }]
    }], null, { arrayLength: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const BASE64_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => Base64Validator),
    multi: true
};
class Base64Validator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return base64(c);
    }
}
Base64Validator.Éµfac = function Base64Validator_Factory(t) { return new (t || Base64Validator)(); };
Base64Validator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: Base64Validator, selectors: [["", "base64", "", "formControlName", ""], ["", "base64", "", "formControl", ""], ["", "base64", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([BASE64_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(Base64Validator, [{
        type: Directive,
        args: [{
                selector: '[base64][formControlName],[base64][formControl],[base64][ngModel]',
                providers: [BASE64_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CREDIT_CARD_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => CreditCardValidator),
    multi: true
};
class CreditCardValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return creditCard(c);
    }
}
CreditCardValidator.Éµfac = function CreditCardValidator_Factory(t) { return new (t || CreditCardValidator)(); };
CreditCardValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: CreditCardValidator, selectors: [["", "creditCard", "", "formControlName", ""], ["", "creditCard", "", "formControl", ""], ["", "creditCard", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([CREDIT_CARD_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(CreditCardValidator, [{
        type: Directive,
        args: [{
                selector: '[creditCard][formControlName],[creditCard][formControl],[creditCard][ngModel]',
                providers: [CREDIT_CARD_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DateValidator),
    multi: true
};
class DateValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return date(c);
    }
}
DateValidator.Éµfac = function DateValidator_Factory(t) { return new (t || DateValidator)(); };
DateValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: DateValidator, selectors: [["", "date", "", "formControlName", ""], ["", "date", "", "formControl", ""], ["", "date", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([DATE_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(DateValidator, [{
        type: Directive,
        args: [{
                selector: '[date][formControlName],[date][formControl],[date][ngModel]',
                providers: [DATE_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DATE_ISO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DateISOValidator),
    multi: true
};
class DateISOValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return dateISO(c);
    }
}
DateISOValidator.Éµfac = function DateISOValidator_Factory(t) { return new (t || DateISOValidator)(); };
DateISOValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: DateISOValidator, selectors: [["", "dateISO", "", "formControlName", ""], ["", "dateISO", "", "formControl", ""], ["", "dateISO", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([DATE_ISO_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(DateISOValidator, [{
        type: Directive,
        args: [{
                selector: '[dateISO][formControlName],[dateISO][formControl],[dateISO][ngModel]',
                providers: [DATE_ISO_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DIGITS_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => DigitsValidator),
    multi: true
};
class DigitsValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return digits(c);
    }
}
DigitsValidator.Éµfac = function DigitsValidator_Factory(t) { return new (t || DigitsValidator)(); };
DigitsValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: DigitsValidator, selectors: [["", "digits", "", "formControlName", ""], ["", "digits", "", "formControl", ""], ["", "digits", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([DIGITS_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(DigitsValidator, [{
        type: Directive,
        args: [{
                selector: '[digits][formControlName],[digits][formControl],[digits][ngModel]',
                providers: [DIGITS_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const EMAIL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EmailValidator),
    multi: true
};
class EmailValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return email(c);
    }
}
EmailValidator.Éµfac = function EmailValidator_Factory(t) { return new (t || EmailValidator)(); };
EmailValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: EmailValidator, selectors: [["", "ngvemail", "", "formControlName", ""], ["", "ngvemail", "", "formControl", ""], ["", "ngvemail", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([EMAIL_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(EmailValidator, [{
        type: Directive,
        args: [{
                selector: '[ngvemail][formControlName],[ngvemail][formControl],[ngvemail][ngModel]',
                providers: [EMAIL_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EqualValidator),
    multi: true
};
class EqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = equal(this.equal);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'equal') {
                this.validator = equal(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
EqualValidator.Éµfac = function EqualValidator_Factory(t) { return new (t || EqualValidator)(); };
EqualValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: EqualValidator, selectors: [["", "equal", "", "formControlName", ""], ["", "equal", "", "formControl", ""], ["", "equal", "", "ngModel", ""]], inputs: { equal: "equal" }, features: [Éµngcc0.ÉµÉµProvidersFeature([EQUAL_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
EqualValidator.propDecorators = {
    equal: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(EqualValidator, [{
        type: Directive,
        args: [{
                selector: '[equal][formControlName],[equal][formControl],[equal][ngModel]',
                providers: [EQUAL_VALIDATOR]
            }]
    }], null, { equal: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const EQUAL_TO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => EqualToValidator),
    multi: true
};
class EqualToValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = equalTo(this.equalTo);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
EqualToValidator.Éµfac = function EqualToValidator_Factory(t) { return new (t || EqualToValidator)(); };
EqualToValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: EqualToValidator, selectors: [["", "equalTo", "", "formControlName", ""], ["", "equalTo", "", "formControl", ""], ["", "equalTo", "", "ngModel", ""]], inputs: { equalTo: "equalTo" }, features: [Éµngcc0.ÉµÉµProvidersFeature([EQUAL_TO_VALIDATOR])] });
EqualToValidator.propDecorators = {
    equalTo: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(EqualToValidator, [{
        type: Directive,
        args: [{
                selector: '[equalTo][formControlName],[equalTo][formControl],[equalTo][ngModel]',
                providers: [EQUAL_TO_VALIDATOR]
            }]
    }], null, { equalTo: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const GREATER_THAN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => GreaterThanValidator),
    multi: true
};
class GreaterThanValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = gt(this.gt);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'gt') {
                this.validator = gt(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
GreaterThanValidator.Éµfac = function GreaterThanValidator_Factory(t) { return new (t || GreaterThanValidator)(); };
GreaterThanValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: GreaterThanValidator, selectors: [["", "gt", "", "formControlName", ""], ["", "gt", "", "formControl", ""], ["", "gt", "", "ngModel", ""]], inputs: { gt: "gt" }, features: [Éµngcc0.ÉµÉµProvidersFeature([GREATER_THAN_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
GreaterThanValidator.propDecorators = {
    gt: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(GreaterThanValidator, [{
        type: Directive,
        args: [{
                selector: '[gt][formControlName],[gt][formControl],[gt][ngModel]',
                providers: [GREATER_THAN_VALIDATOR]
            }]
    }], null, { gt: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const GREATER_THAN_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => GreaterThanEqualValidator),
    multi: true
};
class GreaterThanEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = gte(this.gte);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'gte') {
                this.validator = gte(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
GreaterThanEqualValidator.Éµfac = function GreaterThanEqualValidator_Factory(t) { return new (t || GreaterThanEqualValidator)(); };
GreaterThanEqualValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: GreaterThanEqualValidator, selectors: [["", "gte", "", "formControlName", ""], ["", "gte", "", "formControl", ""], ["", "gte", "", "ngModel", ""]], inputs: { gte: "gte" }, features: [Éµngcc0.ÉµÉµProvidersFeature([GREATER_THAN_EQUAL_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
GreaterThanEqualValidator.propDecorators = {
    gte: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(GreaterThanEqualValidator, [{
        type: Directive,
        args: [{
                selector: '[gte][formControlName],[gte][formControl],[gte][ngModel]',
                providers: [GREATER_THAN_EQUAL_VALIDATOR]
            }]
    }], null, { gte: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const JSON_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => JSONValidator),
    multi: true
};
class JSONValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return json(c);
    }
}
JSONValidator.Éµfac = function JSONValidator_Factory(t) { return new (t || JSONValidator)(); };
JSONValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: JSONValidator, selectors: [["", "json", "", "formControlName", ""], ["", "json", "", "formControl", ""], ["", "json", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([JSON_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(JSONValidator, [{
        type: Directive,
        args: [{
                selector: '[json][formControlName],[json][formControl],[json][ngModel]',
                providers: [JSON_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const LESS_THAN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => LessThanValidator),
    multi: true
};
class LessThanValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = lt(this.lt);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'lt') {
                this.validator = lt(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
LessThanValidator.Éµfac = function LessThanValidator_Factory(t) { return new (t || LessThanValidator)(); };
LessThanValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: LessThanValidator, selectors: [["", "lt", "", "formControlName", ""], ["", "lt", "", "formControl", ""], ["", "lt", "", "ngModel", ""]], inputs: { lt: "lt" }, features: [Éµngcc0.ÉµÉµProvidersFeature([LESS_THAN_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
LessThanValidator.propDecorators = {
    lt: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(LessThanValidator, [{
        type: Directive,
        args: [{
                selector: '[lt][formControlName],[lt][formControl],[lt][ngModel]',
                providers: [LESS_THAN_VALIDATOR]
            }]
    }], null, { lt: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const LESS_THAN_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => LessThanEqualValidator),
    multi: true
};
class LessThanEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = lte(this.lte);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'lte') {
                this.validator = lte(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
LessThanEqualValidator.Éµfac = function LessThanEqualValidator_Factory(t) { return new (t || LessThanEqualValidator)(); };
LessThanEqualValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: LessThanEqualValidator, selectors: [["", "lte", "", "formControlName", ""], ["", "lte", "", "formControl", ""], ["", "lte", "", "ngModel", ""]], inputs: { lte: "lte" }, features: [Éµngcc0.ÉµÉµProvidersFeature([LESS_THAN_EQUAL_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
LessThanEqualValidator.propDecorators = {
    lte: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(LessThanEqualValidator, [{
        type: Directive,
        args: [{
                selector: '[lte][formControlName],[lte][formControl],[lte][ngModel]',
                providers: [LESS_THAN_EQUAL_VALIDATOR]
            }]
    }], null, { lte: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MaxValidator),
    multi: true
};
class MaxValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = max(this.max);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'max') {
                this.validator = max(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MaxValidator.Éµfac = function MaxValidator_Factory(t) { return new (t || MaxValidator)(); };
MaxValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: MaxValidator, selectors: [["", "max", "", "formControlName", ""], ["", "max", "", "formControl", ""], ["", "max", "", "ngModel", ""]], inputs: { max: "max" }, features: [Éµngcc0.ÉµÉµProvidersFeature([MAX_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
MaxValidator.propDecorators = {
    max: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(MaxValidator, [{
        type: Directive,
        args: [{
                selector: '[max][formControlName],[max][formControl],[max][ngModel]',
                providers: [MAX_VALIDATOR]
            }]
    }], null, { max: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MAX_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MaxDateValidator),
    multi: true
};
class MaxDateValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = maxDate(this.maxDate);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'maxDate') {
                this.validator = maxDate(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MaxDateValidator.Éµfac = function MaxDateValidator_Factory(t) { return new (t || MaxDateValidator)(); };
MaxDateValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: MaxDateValidator, selectors: [["", "maxDate", "", "formControlName", ""], ["", "maxDate", "", "formControl", ""], ["", "maxDate", "", "ngModel", ""]], inputs: { maxDate: "maxDate" }, features: [Éµngcc0.ÉµÉµProvidersFeature([MAX_DATE_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
MaxDateValidator.propDecorators = {
    maxDate: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(MaxDateValidator, [{
        type: Directive,
        args: [{
                selector: '[maxDate][formControlName],[maxDate][formControl],[maxDate][ngModel]',
                providers: [MAX_DATE_VALIDATOR]
            }]
    }], null, { maxDate: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MIN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MinValidator),
    multi: true
};
class MinValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = min(this.min);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'min') {
                this.validator = min(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MinValidator.Éµfac = function MinValidator_Factory(t) { return new (t || MinValidator)(); };
MinValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: MinValidator, selectors: [["", "min", "", "formControlName", ""], ["", "min", "", "formControl", ""], ["", "min", "", "ngModel", ""]], inputs: { min: "min" }, features: [Éµngcc0.ÉµÉµProvidersFeature([MIN_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
MinValidator.propDecorators = {
    min: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(MinValidator, [{
        type: Directive,
        args: [{
                selector: '[min][formControlName],[min][formControl],[min][ngModel]',
                providers: [MIN_VALIDATOR]
            }]
    }], null, { min: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const MIN_DATE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => MinDateValidator),
    multi: true
};
class MinDateValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = minDate(this.minDate);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'minDate') {
                this.validator = minDate(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
MinDateValidator.Éµfac = function MinDateValidator_Factory(t) { return new (t || MinDateValidator)(); };
MinDateValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: MinDateValidator, selectors: [["", "minDate", "", "formControlName", ""], ["", "minDate", "", "formControl", ""], ["", "minDate", "", "ngModel", ""]], inputs: { minDate: "minDate" }, features: [Éµngcc0.ÉµÉµProvidersFeature([MIN_DATE_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
MinDateValidator.propDecorators = {
    minDate: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(MinDateValidator, [{
        type: Directive,
        args: [{
                selector: '[minDate][formControlName],[minDate][formControl],[minDate][ngModel]',
                providers: [MIN_DATE_VALIDATOR]
            }]
    }], null, { minDate: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NOT_EQUAL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NotEqualValidator),
    multi: true
};
class NotEqualValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = notEqual(this.notEqual);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'notEqual') {
                this.validator = notEqual(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
NotEqualValidator.Éµfac = function NotEqualValidator_Factory(t) { return new (t || NotEqualValidator)(); };
NotEqualValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: NotEqualValidator, selectors: [["", "notEqual", "", "formControlName", ""], ["", "notEqual", "", "formControl", ""], ["", "notEqual", "", "ngModel", ""]], inputs: { notEqual: "notEqual" }, features: [Éµngcc0.ÉµÉµProvidersFeature([NOT_EQUAL_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
NotEqualValidator.propDecorators = {
    notEqual: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NotEqualValidator, [{
        type: Directive,
        args: [{
                selector: '[notEqual][formControlName],[notEqual][formControl],[notEqual][ngModel]',
                providers: [NOT_EQUAL_VALIDATOR]
            }]
    }], null, { notEqual: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NOT_EQUAL_TO_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NotEqualToValidator),
    multi: true
};
class NotEqualToValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = notEqualTo(this.notEqualTo);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
}
NotEqualToValidator.Éµfac = function NotEqualToValidator_Factory(t) { return new (t || NotEqualToValidator)(); };
NotEqualToValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: NotEqualToValidator, selectors: [["", "notEqualTo", "", "formControlName", ""], ["", "notEqualTo", "", "formControl", ""], ["", "notEqualTo", "", "ngModel", ""]], inputs: { notEqualTo: "notEqualTo" }, features: [Éµngcc0.ÉµÉµProvidersFeature([NOT_EQUAL_TO_VALIDATOR])] });
NotEqualToValidator.propDecorators = {
    notEqualTo: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NotEqualToValidator, [{
        type: Directive,
        args: [{
                selector: '[notEqualTo][formControlName],[notEqualTo][formControl],[notEqualTo][ngModel]',
                providers: [NOT_EQUAL_TO_VALIDATOR]
            }]
    }], null, { notEqualTo: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NUMBER_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NumberValidator),
    multi: true
};
class NumberValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return number(c);
    }
}
NumberValidator.Éµfac = function NumberValidator_Factory(t) { return new (t || NumberValidator)(); };
NumberValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: NumberValidator, selectors: [["", "number", "", "formControlName", ""], ["", "number", "", "formControl", ""], ["", "number", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([NUMBER_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(NumberValidator, [{
        type: Directive,
        args: [{
                selector: '[number][formControlName],[number][formControl],[number][ngModel]',
                providers: [NUMBER_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const PROPERTY_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => PropertyValidator),
    multi: true
};
class PropertyValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = property(this.property);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'property') {
                this.validator = property(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
PropertyValidator.Éµfac = function PropertyValidator_Factory(t) { return new (t || PropertyValidator)(); };
PropertyValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: PropertyValidator, selectors: [["", "property", "", "formControlName", ""], ["", "property", "", "formControl", ""], ["", "property", "", "ngModel", ""]], inputs: { property: "property" }, features: [Éµngcc0.ÉµÉµProvidersFeature([PROPERTY_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
PropertyValidator.propDecorators = {
    property: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(PropertyValidator, [{
        type: Directive,
        args: [{
                selector: '[property][formControlName],[property][formControl],[property][ngModel]',
                providers: [PROPERTY_VALIDATOR]
            }]
    }], null, { property: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const RANGE_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeValidator),
    multi: true
};
class RangeValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = range(this.range);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'range') {
                this.validator = range(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
RangeValidator.Éµfac = function RangeValidator_Factory(t) { return new (t || RangeValidator)(); };
RangeValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: RangeValidator, selectors: [["", "range", "", "formControlName", ""], ["", "range", "", "formControl", ""], ["", "range", "", "ngModel", ""]], inputs: { range: "range" }, features: [Éµngcc0.ÉµÉµProvidersFeature([RANGE_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
RangeValidator.propDecorators = {
    range: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(RangeValidator, [{
        type: Directive,
        args: [{
                selector: '[range][formControlName],[range][formControl],[range][ngModel]',
                providers: [RANGE_VALIDATOR]
            }]
    }], null, { range: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const RANGE_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => RangeLengthValidator),
    multi: true
};
class RangeLengthValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = rangeLength(this.rangeLength);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'rangeLength') {
                this.validator = rangeLength(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
RangeLengthValidator.Éµfac = function RangeLengthValidator_Factory(t) { return new (t || RangeLengthValidator)(); };
RangeLengthValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: RangeLengthValidator, selectors: [["", "rangeLength", "", "formControlName", ""], ["", "rangeLength", "", "formControl", ""], ["", "rangeLength", "", "ngModel", ""]], inputs: { rangeLength: "rangeLength" }, features: [Éµngcc0.ÉµÉµProvidersFeature([RANGE_LENGTH_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
RangeLengthValidator.propDecorators = {
    rangeLength: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(RangeLengthValidator, [{
        type: Directive,
        args: [{
                selector: '[rangeLength][formControlName],[rangeLength][formControl],[rangeLength][ngModel]',
                providers: [RANGE_LENGTH_VALIDATOR]
            }]
    }], null, { rangeLength: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const URL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => UrlValidator),
    multi: true
};
class UrlValidator {
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return url(c);
    }
}
UrlValidator.Éµfac = function UrlValidator_Factory(t) { return new (t || UrlValidator)(); };
UrlValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: UrlValidator, selectors: [["", "url", "", "formControlName", ""], ["", "url", "", "formControl", ""], ["", "url", "", "ngModel", ""]], features: [Éµngcc0.ÉµÉµProvidersFeature([URL_VALIDATOR])] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(UrlValidator, [{
        type: Directive,
        args: [{
                selector: '[url][formControlName],[url][formControl],[url][ngModel]',
                providers: [URL_VALIDATOR]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const UUID_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => UUIDValidator),
    multi: true
};
class UUIDValidator {
    /**
     * @return {?}
     */
    ngOnInit() {
        this.validator = uuid(this.uuid);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        for (const /** @type {?} */ key in changes) {
            if (key === 'uuid') {
                this.validator = uuid(changes[key].currentValue);
                if (this.onChange) {
                    this.onChange();
                }
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
}
UUIDValidator.Éµfac = function UUIDValidator_Factory(t) { return new (t || UUIDValidator)(); };
UUIDValidator.Éµdir = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineDirective({ type: UUIDValidator, selectors: [["", "uuid", "", "formControlName", ""], ["", "uuid", "", "formControl", ""], ["", "uuid", "", "ngModel", ""]], inputs: { uuid: "uuid" }, features: [Éµngcc0.ÉµÉµProvidersFeature([UUID_VALIDATOR]), Éµngcc0.ÉµÉµNgOnChangesFeature] });
UUIDValidator.propDecorators = {
    uuid: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(UUIDValidator, [{
        type: Directive,
        args: [{
                selector: '[uuid][formControlName],[uuid][formControl],[uuid][ngModel]',
                providers: [UUID_VALIDATOR]
            }]
    }], null, { uuid: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const CustomValidators = {
    arrayLength,
    base64,
    creditCard,
    date,
    dateISO,
    digits,
    email,
    equal,
    equalTo,
    gt,
    gte,
    json,
    lt,
    lte,
    max,
    maxDate,
    min,
    minDate,
    notEqual,
    notEqualTo,
    number,
    property,
    range,
    rangeLength,
    url,
    uuid
};
const CustomDirectives = [
    ArrayLengthValidator,
    Base64Validator,
    CreditCardValidator,
    DateValidator,
    DateISOValidator,
    DigitsValidator,
    EmailValidator,
    EqualValidator,
    EqualToValidator,
    GreaterThanValidator,
    GreaterThanEqualValidator,
    JSONValidator,
    LessThanValidator,
    LessThanEqualValidator,
    MaxValidator,
    MaxDateValidator,
    MinValidator,
    MinDateValidator,
    NotEqualValidator,
    NotEqualToValidator,
    NumberValidator,
    PropertyValidator,
    RangeValidator,
    RangeLengthValidator,
    UrlValidator,
    UUIDValidator
];
class CustomFormsModule {
}
CustomFormsModule.Éµfac = function CustomFormsModule_Factory(t) { return new (t || CustomFormsModule)(); };
CustomFormsModule.Éµmod = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineNgModule({ type: CustomFormsModule });
CustomFormsModule.Éµinj = /*@__PURE__*/ Éµngcc0.ÉµÉµdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && Éµngcc0.ÉµsetClassMetadata(CustomFormsModule, [{
        type: NgModule,
        args: [{
                declarations: [CustomDirectives],
                exports: [CustomDirectives]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(CustomFormsModule, { declarations: [ArrayLengthValidator, Base64Validator, CreditCardValidator, DateValidator, DateISOValidator, DigitsValidator, EmailValidator, EqualValidator, EqualToValidator, GreaterThanValidator, GreaterThanEqualValidator, JSONValidator, LessThanValidator, LessThanEqualValidator, MaxValidator, MaxDateValidator, MinValidator, MinDateValidator, NotEqualValidator, NotEqualToValidator, NumberValidator, PropertyValidator, RangeValidator, RangeLengthValidator, UrlValidator, UUIDValidator], exports: [ArrayLengthValidator, Base64Validator, CreditCardValidator, DateValidator, DateISOValidator, DigitsValidator, EmailValidator, EqualValidator, EqualToValidator, GreaterThanValidator, GreaterThanEqualValidator, JSONValidator, LessThanValidator, LessThanEqualValidator, MaxValidator, MaxDateValidator, MinValidator, MinDateValidator, NotEqualValidator, NotEqualToValidator, NumberValidator, PropertyValidator, RangeValidator, RangeLengthValidator, UrlValidator, UUIDValidator] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { CustomValidators, CustomFormsModule, ArrayLengthValidator as Éµba, arrayLength as Éµa, Base64Validator as Éµbb, base64 as Éµb, CreditCardValidator as Éµbc, creditCard as Éµc, DateISOValidator as Éµbe, dateISO as Éµe, DateValidator as Éµbd, date as Éµd, DigitsValidator as Éµbf, digits as Éµf, EmailValidator as Éµbg, email as Éµg, EqualToValidator as Éµbi, equalTo as Éµi, EqualValidator as Éµbh, equal as Éµh, GreaterThanEqualValidator as Éµbk, gte as Éµk, GreaterThanValidator as Éµbj, gt as Éµj, JSONValidator as Éµbl, json as Éµl, LessThanEqualValidator as Éµbn, lte as Éµn, LessThanValidator as Éµbm, lt as Éµm, MaxDateValidator as Éµbp, maxDate as Éµp, MaxValidator as Éµbo, max as Éµo, MinDateValidator as Éµbr, minDate as Éµr, MinValidator as Éµbq, min as Éµq, NotEqualToValidator as Éµbt, notEqualTo as Éµt, NotEqualValidator as Éµbs, notEqual as Éµs, NumberValidator as Éµbu, number as Éµu, PropertyValidator as Éµbv, property as Éµv, RangeLengthValidator as Éµbx, rangeLength as Éµx, RangeValidator as Éµbw, range as Éµw, UrlValidator as Éµby, url as Éµy, UUIDValidator as Éµbz, uuid as Éµz };

//# sourceMappingURL=ng4-validators.js.map